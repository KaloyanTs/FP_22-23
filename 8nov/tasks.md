# 05. Fold. Дълбоки списъци

Интересни неща за работа с низове в упражнението на [inf1/04-scheme-strings](https://github.com/triffon/fp-2022-23/tree/main/exercises/inf1/04-scheme-strings). Няма да ни трябват за контролни, има употреба главно при проектите.

![foldr](../../inf2/05/foldr.png)

![foldl](../../inf2/foldl-racket.png)

#### [Сваляне на задачите](https://download-directory.github.io/?url=https%3A%2F%2Fgithub.com%2Ftriffon%2Ffp-2022-23%2Ftree%2Fmaster%2Fexercises%2Fcs2%2F05.scheme.fold-deeplists)

### [Задача 1](./01.maximum.rkt) (много полезна)
Напишете функция `(maximum l)`,
която намира най-големия елемент в l.

### Задача 1.5 (полезна)
Напишете функция `(argmin f l)`,
която намира елемент `x` на `l`, за който `(f x)` има най-малка стойност, тоест ∀y∈l( f(x) ≤ f(y) ).

### [Задача 2](./02.selection-sort.rkt)
Напишете функция `(selection-sort l)`
която сортира списъка l по алгоритъма [selection sort](https://en.wikipedia.org/wiki/Selection_sort).
Пример:
```scheme
(selection-sort '(5 1 2 6 3)) -> '(1 2 3 5 6)
```
> Упътване: използвайте `remove` от миналото упражнение.

### [Задача 3](./03.slice.rkt)
Напишете функция `(slice a b l)`,
която връща подсписъкът на l от позиция a до позиция b. Позициите започват от 0.
Пример:
```scheme
(slice 3 7 '(1 2 3 4 5 6 7 8 9)) -> '(4 5 6 7 8)
```
> Упътване: припомнете си `take` и `drop` от миналото упражнение.

### [Задача 4](./04.zip.rkt) (полезна, повечко в Хаскел)
Напишете функция `(zip l m)`,
която връща списък от наредени двойки от елементите на l и m.
Пример:
```scheme
(zip '(1 2 3) '(4 5 6)) -> '((1 . 4) (2 . 5) (3 . 6))
```

### [Задача 5](./05.zip-with.rkt) (полезна, повечко в Хаскел)
Напишете функция `(zip-with f l m)`,
която връща списък от прилагането на f върху елемент на l и елемент на m.
Пример:
```scheme
(zip-with * '(1 2 3) '(4 5 6)) -> '(4 10 18)
(zip-with cons '(1 2 3) '(4 5 6)) -> '((1 . 4) (2 . 5) (3 . 6))
```
Каква е връзката между `zip` и `zip-with`?

### [Задача 6](./06.unique.rkt)
Напишете функция `(unique l)`,
която връща списък от елементите на l без повторения.
Пример:
```scheme
(unique '(1 2 3 3 3 4 3 3 5 5 3)) -> '(1 2 3 4 5)
```

### [Задача 7](./07.intersection.rkt)
Напишете функция `(intersection l m)`,
която връща списък с елементите, които се срещат едновременно в l и m, без повторения.
Пример:
```scheme
(intersection '(1 2 3 4) '(6 1 4 5)) -> '(1 4)
```
Този списък представя сечение на множествата от елементите на l и m.

### [Задача 8](./08.union.rkt)
Напишете функция `(union l m)`,
която връща списък с елементите на l и m, без повторения.
Пример:
```scheme
(union '(1 2 3 4) '(6 1 4 5)) -> '(1 2 3 4 6 5)
```
Този списък представя обединение на множествата от елементите на l и m.

### [Задача 9](./09.set-minus.rkt)
Напишете функция `(set-minus l m)`,
която връща списък с елементите на l, които не са елементи на m, без повторения.
Пример:
```scheme
(set-minus '(1 2 3 4 5 6) '(6 1 4)) -> '(2 3 5)
```
Този списък представя разлика на множествата от елементите на l и m.


### [Задача 10](./10.chunk.rkt)
Напишете функция `(chunk n l)`,
която връща списък от последователните подсписъци на l с дължина n.
Пример:
```scheme
(chunk 3 '(1 2 3 4 5 6 7 8 9 10)) -> '((1 2 3) (4 5 6) (7 8 9) (10))
```

### [Задача 11](./11.selection-sort.rkt)
Напишете функция `(selection-sort less l)`
която сортира списъка l по алгоритъма [selection sort](https://en.wikipedia.org/wiki/Selection_sort), използвайки `less` като функция за сравнение на два елемента.
Пример:
```scheme
(selection-sort > '(5 1 2 6 3)) -> '(6 5 3 2 1)
```

---

### [Задача 12](./12.count-atoms.rkt)
Напишете функция `(count-atoms dl)`,
която намира броя атоми в дълбокия списък dl.
Пример:
```scheme
(count-atoms '((1 2 3) (4) ((5 6) ((7))))) -> 7
```

### [Задача 13](./13.flatten.rkt)
Напишете функция `(flatten dl)`,
която връща списък от атомите в дълбокия списък dl.
Пример:
```scheme
(flatten '((1 2 3) (4) ((5 6) ((7))))) -> '(1 2 3 4 5 6 7)
```

### [Задача 14](./14.deep-reverse.rkt)
Напишете функция `(deep-reverse dl)`,
която обръща реда на елементите във всеки списък в дълбокия списък dl.
Пример:
```scheme
(deep-reverse '((1 2 3) (4) ((5 6) ((7))))) -> '((((7)) (6 5)) (4) (3 2 1))
```

---

### [Задача 15](./15.quicksort.rkt)
Напишете функция `(quicksort l)`,
която сортира списъка l по алгоритъма [quicksort](https://en.wikipedia.org/wiki/Quicksort). Като pivot може да ползвате първия елемент на списъка, за най-лесно.

---

### Задача 16
Отворен числов интервал `(a;b)` се описва с наредената двойка `(a . b)`. Да се напише функция `longest-interval-subsets`, която по даден списък от интервали `il` връща нов списък, който съдържа всички интервали от `il`, които са подинтервали на най-дългия интервал в списъка.
Бонус: Функцията `longest-interval-subsets` да връща подинтервалите подредени в нарастващ ред по началната си точка.
```
(longest-interval-subsets
  '((24 . 25) (90 . 110) (0 . 100) (10 . 109) (1 . 3) (-4 . 2)))
-> ((0 . 100) (1 . 3) (24 . 25))
```
### Задача 17
Да се напише функция `(group-by f lst)`, която групира елементите на списъка `lst` по стойността, която `f` връща за тях. Конкретно, за всяка върната от `f` стойност над някой елемент от `lst` трябва да върнете списък с два елемента - тази стойност и списъкът от елементите на `lst`, за които се получава тя.
```
(group-by even? '(1 2 3 4 5)) -> ((#f (1 3 5))
                                  (#t (2 4))) ; подредбата няма значение
(group-by length '((1 2 3) (4) (5 6 7))) -> '((1 ((4)))
                                              (3 ((1 2 3) (5 6 7))))
```

---

### Задача 18 (вариант Б, задача 3 от контролно 2019-20)
(10  т.)  “Ниво  на  влагане”  на  атом  в  дълбок  списък
наричаме броя пъти, който трябва да се приложи операцията car за
достигане до атома. Да се реализира функция `deep-delete`, която в
даден дълбок списък изтрива всички числови атоми, които са по-
малки от нивото им на влагане.
Пример:
```scheme
(deep-delete '(1 (2 (2 4) 1) 0 (3 (1)))) → (1 (2 (4)) (3 ()))
```

### Задача 19 (задача 4 от контролно 2015-16)
(8 т.) Да се напише функция  `(longestAscending l)`,
която намира възходящо сортиран подсписък на списъка от числа l с
максимална дължина. Ако съществуват няколко такива подсписъка,
функцията да върне първия отдясно наляво.
Упътване: Реализирайте  помощна  функция,  която  намира  най-дългия
възходящо сортиран префикс на даден списък.
Пример:
```scheme
(longestAscending ‘(5 3 8 6 4 2 6 7 1)) → (2 6 7)
```