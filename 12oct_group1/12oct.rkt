#lang racket
(define (f2 x y)
  (define (in-box? x y)
    (and (<= (abs x) 1) (<= (abs y) 1))
    )
  (and (in-box? x y)
       (in-box? (- x 2) (- y 2))
       (in-box? (- x 4) (- y 4))
       )
  )

(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1)) (fib (- n 2))))
        )
  )

(define (div-sum n)
  (define (iter i s)
    (if (<= i n)
        (if (= 0 (remainder n i))
            (iter (+ i 1) (+ s i))
            (iter (+ i 1) s)
            ) 
        s
        )
    )
  (iter 1 0)
  )

(define (perfect? n)
  (= (* 2 n) (div-sum n))
  )

(define (prime? n)
  (define (any-div i lim)
    (if (> i lim)
        #f
        (if (= 0 (remainder n i))
            #t
            (any-div (+ i 1) lim)
            )
        )
    )
  (and (> n 1) (not (any-div 2 (sqrt n))))
  )

(define (bad-prime? n)
  (= (+ n 1) (div-sum n))
  )

(define (increasing? n)
  (if (< n 10)
      #t
      (and (>
            (remainder n 10)
            (quotient (- (remainder n 100) (remainder n 10)) 10)
            )
           (increasing? (quotient n 10))
           )
      )
  )

(define (rev-dig-iter n)
  (define (iter i r)
    (if (< i 10)
        (+ (* 10 r) i)
        (iter (quotient i 10) (+ (* r 10) (remainder i 10)))
        )
    )
  (iter n 0)
  )

(define (toBinary n)
  (cond ((= n 1) 1)
        ((even? n) (* 10 (toBinary (quotient n 2))))
        (else (+ 1 (* 10 (toBinary (quotient n 2)))))
        )
  )

(define (toBinaryIter n)
  (define (iter i r)
    (if (= i 1)
        (+ (* 10 r) 1)
        (iter (quotient i 2) (+ (* r 10) (remainder i 2)))
    )
  )
  (quotient (- (rev-dig-iter (iter n 1)) 1) 10)
  )

(define (toDecimal n)
  (if (= n 1)
      1
      (+ (remainder n 10) (* 2 (toDecimal (quotient n 10))))
      )
  )

(define (toDecimalIter n)
  (define (iter i r)
    (if (= i 1)
        r
        (iter (quotient i 10) (+ (* 2 r) (remainder i 10)))
        )
    )
  (iter (rev-dig-iter (+ 1 (* n 10))) 0)
  )