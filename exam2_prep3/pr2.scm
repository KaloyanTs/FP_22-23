#lang racket

(define root car)
(define left cadr)
(define right caddr)
(define (isLeaf? t) (and (not (null? t))
                         (null? (left t))
                         (null? (right t))
                         )
  )

(define (toDecimal p)
  (cond ((null? p) 0)
        ((zero? (car p)) (* 2 (toDecimal (cdr p))))
        (else (+ 1 (* 2 (toDecimal (cdr p)))))
        )
  )

(define (sameAsCode t)
  (define (helper t pathCode)
    (cond ((null? t) 0)
          ((= (toDecimal pathCode) (root t))
           (root t)
           )
          (else (let ((lRes (helper
                             (left t)
                             (cons 0 pathCode)
                             )
                            )
                      (rRes (helper
                             (right t)
                             (cons 1 pathCode)
                             )
                            )
                      )
                  (max lRes rRes)
                  )
                )
          )
    )
  (helper t '(1))
  )