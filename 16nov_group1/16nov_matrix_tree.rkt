#lang racket

(define head car)
(define tail cdr)

(define (head-rows m) (head m))
(define (head-cols m) (map head m))
(define (tail-rows m) (tail m))
(define (tail-cols m) (map tail m))
(define (null-m? m) (or (null? m) (null? (head m))))

(define (zipWith op l1 l2)
  (if (or (null? l1)
          (null? l2)
          )
      '()
      (cons (op (car l1) (car l2))
            (zipWith op
                     (cdr l1)
                     (cdr l2)
                     )
            )
      )
  )

(define (all? p? l)
  (null? (filter (lambda (x) (not (p? x)))
                 l
                 )
         )
  )

(define (dependent? r1 r2)
  (define q (zipWith (lambda (x y) (if (zero? y)
                                       #f
                                       (/ x y)
                                       )
                       )
                     r1
                     r2
                     )
    )
  (all? (lambda (x) (equal? x (car q))) (cdr q))
  )

(define (all-two-independent lr)
  (cond ((< (length lr) 1) #t)
        (else (and (all? (lambda (x) (not (dependent? x
                                                      (car lr)
                                                      )
                                          )
                           )
                         (cdr lr)
                         )
                   (all-two-independent (cdr lr))
                   )
              )
        )
  )

(define (fails m)
  (if (not (all? (lambda (x) (not (dependent? x (car m))))
                 (cdr m)
                 )
           )
      (car m)
      (fails (cdr m))
      )
  )

(define (remove r m)
  (if (equal? r (car m))
      (cdr m)
      (cons (car m) (remove r (cdr m)))
      )
  )

(define (pseudorank m)
  (cond ((all-two-independent m) (length m))
        (else (pseudorank (remove (fails m) m)))
        )
  )

(define (gauss row1 row2)
  (if (null? row1) '()
      (if (zero? (car row1))
          (cons (car row2) (gauss (cdr row1) (cdr row2)))
          (let ((q (- 0 (/ (car row2) (car row1)))))
            (zipWith + row2 (map (lambda (x) (* x q)) row1))
            )
          )
      )
  )

(define (gauss-elimination m)
  (define el (cons (car m)
                   (map (lambda (r) (gauss (car m) r))
                        (cdr m)
                        )
                   )
    )
  (if (< (length m) 2)
      m
      (cons (car el) (gauss-elimination (cdr el)))
      )
  )

(define (at-col i r)
  (if (= i 1) (car r)
      (at-col (- i 1) (cdr r))
      )
  )

(define (triangular-det m)
  (define (iter num res mat)
    (if (null? mat) res
        (iter (+ num 1)
              (* res (at-col num (car mat)))
              (cdr mat)
              )
        )
    )
  (iter 1 1 m)
  )

(define (determinant m)
  (triangular-det (gauss-elimination m))
  )

(define (tree? t)
  (or (null? t)
      (and (list? t)
           (= (length t) 3))
      (tree? (cadr t))
      (tree? (caddr t))))
(define empty-tree '())
(define (make-tree root left right) (list root left right))      ; не искаме просто (define make-tree list) - защо?
(define (make-leaf root) (make-tree root empty-tree empty-tree)) ; за удобство
(define root-tree car)
(define left-tree cadr)
(define right-tree caddr)
(define empty-tree? null?)

(define (height t)
  (if (empty-tree? t)
      0
      (+ 1 (max (height (left-tree t))
                (height (right-tree t))
                )
         )
      )
  )

(define (get-level n t)
  (cond ((empty-tree? t) '())
        ((zero? n) (list (root-tree t)))
        (else (append (get-level (- n 1) (left-tree t))
                      (get-level (- n 1) (right-tree t))
                      )
              )
        )
  )

(define (find-longest-path t)
  (cond ((empty-tree? t) '())
        (else (cons (car t)
                    ((lambda (x y) (if (< (length x)
                                          (length y)
                                          )
                                       y
                                       x
                                       )
                       )
                     (find-longest-path (left-tree t))
                     (find-longest-path (right-tree t))
                     )
                    )
              )
        )
  )

(define (tree-map f t)
  (cond ((empty-tree? t) '())
        (make-tree (f (root-tree t))
                   (tree-map f (left-tree t))
                   (tree-map f (right-tree t))
                   )
        )
  )

(define (tree->list t)
  (cond ((empty-tree? t) '())
        (else (append (tree->list (left-tree t))
                      (list (root-tree t))
                      (tree->list (right-tree t))
                      )
              )
        )
  )

(define (bst-insert val t)
  (cond ((empty-tree? t) (make-leaf val))
        ((<= val (root-tree t))
         (make-tree (root-tree t)
                    (bst-insert val
                                (left-tree t)
                                )
                    (right-tree t)
                    )
         )
        (else (make-tree (root-tree t)
                         (left-tree t)
                         (bst-insert val
                                     (right-tree t)
                                     )
                         )
              )
        )
  )

(define (tree-sort lst)
  (tree->list
   (foldr (lambda (x y) (bst-insert x y))
          empty-tree
          lst
          )
   )
  )

(define (is-in-bounds x lb ub); (lb; ub]
  (and (or (not lb)
           (> x lb)
           )
       (or (not ub)
           (<= x ub)
           )
       )
  )

(define (valid-bst? t)
  (define (helper t lb ub)
    (if (empty-tree? t)
        #t
        (and (is-in-bounds (root-tree t) lb ub)
             (helper (left-tree t)
                     lb
                     (root-tree t)
                     )
             (helper (right-tree t)
                     (root-tree t)
                     ub
                     )
             )
        )
    )
  (helper t #f #f)
  )

(define (is-leaf? n)
  (and (empty-tree? (left-tree n))
       (empty-tree? (right-tree n))
       )
  )

(define (prune t)
  (if (or (empty-tree? t)
          (is-leaf? t)
          )
      empty-tree
      (make-tree (root-tree t)
                 (prune (left-tree t))
                 (prune (right-tree t))
                 )
      )
  )

(define (bloom x t)
  (cond ((empty-tree? t) t)
        ((and (is-leaf? t)
              (equal? x (root-tree t))
              )
         (make-tree x (make-leaf x) (make-leaf x))
         )
        (else (make-tree (root-tree t)
                         (bloom x (left-tree t))
                         (bloom x (right-tree t))
                         )
              )
        )
  )

(define (foldl op nv l)
  (if (null? l)
      nv
      (foldl op (op nv (car l)) (cdr l))
      )
  )

(define (toDecimal lBinary)
  (foldl (lambda (x y) (+ (* 2 x) y))
         0
         lBinary
         )
  )

(define (push-back el l)
  (if (null? l) (list el)
      (cons (car l) (push-back el (cdr l))))
  )

(define (same-as-code t)
  (define (helper res tr)
    (if (empty-tree? tr)
        '()
        (append (helper (push-back 0 res) (left-tree tr))
                (if (= (toDecimal res) (root-tree tr))
                    (list (root-tree tr))
                    '()
                    )
                (helper (push-back 1 res) (right-tree tr))
                )
        )
    )
  (helper '() t)
  )

(define (calc-tree f t)
  (cond ((is-leaf? t) (root-tree t))
        (else (f (root-tree t)
                 (if (empty-tree? (left-tree t))
                     (root-tree t)
                     (calc-tree f (left-tree t))
                     )
                 (if (empty-tree? (right-tree t))
                     (root-tree t)
                     (calc-tree f (right-tree t))
                     )
                 )
              )
        )
  )

(define (avg t)
  (define (helper tree)
    (cond ((empty-tree? tree) (make-tree tree tree tree))
          ((is-leaf? tree) (make-tree tree
                                   (root-tree tree)
                                   (root-tree tree)
                                   )
                        )
          (else
           (let* ((l (helper (left-tree tree)))
                  (r (helper (right-tree tree)))
                  (m (cond ((null? (left-tree l))
                            (left-tree r))
                           ((null? (left-tree r))
                            (left-tree l))
                           (else (min
                                  (left-tree l)
                                  (left-tree r)
                                  )
                                 )
                           )
                     )
                  (M (cond ((null? (right-tree l))
                                  (right-tree r))
                           ((null? (right-tree r))
                                  (right-tree l))
                           (else (max
                                  (right-tree l)
                                  (right-tree r)
                                  )
                                 )
                           )
                     )
                  )
             (make-tree (make-tree
                         (/
                          (+
                           m
                           M
                           )
                          2
                          )
                         (root-tree l)
                         (root-tree r)
                         )
                        m
                        M
                        )
             )
           )
          )
    )4
  (root-tree (helper t))
  )

