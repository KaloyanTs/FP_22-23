#lang racket

;(intersection '(1 2 3 4) '(6 1 4 5)) -> '(1 4)

(define (foldr op nv l)
  (if (null? l)
      nv
      (op (car l) (foldr op nv (cdr l)))
      )
  )

(define (filter p? l)
  (cond ((null? l) '())
        ((p? (car l)) (cons (car l) (filter p? (cdr l))))
        (else (filter p? (cdr l)))
        )
  )

(define (member? el l)
  (foldr (lambda (x y) (or y
                           (equal? el
                                   x
                                   )
                           )
           )
         #f
         l
         )
  )

(define (uniques l1)
  (cond ((null? l1) '())
        ((member? (car l1)
                  (cdr l1)
                  )
         (uniques (cdr l1))
         )
        (else (cons (car l1) (uniques (cdr l1))))
        )
  )

(define (intersection l1 l2)
  (define l (uniques l1))
  (filter (lambda (x) (member? x l2))
          l)
  )

(define (union l1 l2)
  (uniques (append l1 l2))
  )

(define (set-minus l1 l2)
  (define l (uniques l1))
  (filter (lambda (x) (not (member? x l2)))
          l)
  )

(define (min-el less l)
  (foldr (lambda (x y) (if (less x y)
                           x
                           y
                           )
           )
         (car l)
         (cdr l)
         )
  )

(define (remove el lst)
  (cdr (foldr (lambda (y x) (if (and (not (car x)) (eq? el y))
                                (cons #t (cdr x))
                                (cons (car x) (cons y (cdr x)))
                                )
                )
              (list #f)
              lst
              )
       )
  )

(define (selection-sort less l)
  (if (< (length l) 2)
      l
      (let ((m (min-el less l)))
        (cons (min-el less l)
              (selection-sort less (remove m l))
              )
        )
      )
  )

(define (take n l)
  (if (zero? n)
      '()
      (cons (car l)
            (take (- n 1)
                  (cdr l)
                  )
            )
      )
  )

(define (slice from to l)
  (if (= from 1)
      (take to l)
      (slice (- from 1)
             (- to 1)
             (cdr l)
             )
      )
  )

(define (atom? x)
  (not (or (null? x) (pair? x)))
  )

(define (count-atoms l)
  (cond ((null? l) 0)
        ((atom? l) 1)
        (else (+ (count-atoms (car l))
                 (count-atoms (cdr l))
                 )
              )
        )
  )

(define (flatten l)
  (cond ((null? l) '())
        ((atom? l) (list l))
        (else (append (flatten (car l))
                      (flatten (cdr l))
                      )
              )
        )
  )

(define (deep-reverse l)
  (cond ((null? l) '())
        ((atom? l) (list l))
        (else (append (deep-reverse (cdr l))
                      (deep-reverse (car l))
                      )
              )
        )
  )

(define (quicksort l)
  (if (< (length l) 2)
      l
      (append (quicksort (filter (lambda (x) (< x (car l)))
                                 l
                                 )
                         )
              (list (car l))
              (quicksort (filter (lambda (x) (> x (car l)))
                                 l
                                 )
                         )
              )
      )              
  )

(define (deep-delete l)
  (helper 1 l)
  )

(define (helper lvl l)
  (cond ((null? l) '())
        ((atom? (car l)) (if (< (car l) lvl)
                             (helper lvl (cdr l))
                             (cons (car l)
                                   (helper lvl (cdr l))
                                   )
                             )
                         )
        (else (cons (helper (+ lvl 1)
                            (car l)
                            )
                    (helper lvl
                            (cdr l)
                            )
                    )
              )
        )
  )

(define (take2 n l)
  (if (zero? n)
      '()
      (cons (car l) (take (- n 1)
                          l
                          )
            )
      )
  )

(define (from-to from to l)
  (if (= from 1)
      (take2 to l)
      (from-to (- from 1)
               (- to 1)
               (cdr l)
               )
      )
  )

(define (max-asc l)
  (define (iter head ll res)
    (if (or (null? ll)
            (> head
               (car ll)
               )
            )
        res
        (iter (car ll) (cdr ll) (cons (car ll)
                                      res
                                      )
              )
        )
    )
  (reverse (if (< (length l) 2)
               l
               (iter (car l)
                     (cdr l)
                     (list (car l))
                     )
               )
           )
  )

(define (longest-from-each l res)
  (if (null? l)
      res
      (longest-from-each (cdr l)
                         (cons (max-asc l)
                               res
                               )
                         )
      )
  )
      
(define (longestAscending l)
  (foldr (lambda (x y) (if (>= (length x)
                           (length y)
                           )
                           x
                           y
                           )
           )
         '()
         (longest-from-each l '())
         )
  )