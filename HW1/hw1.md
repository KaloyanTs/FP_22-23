Важно условие:
Пълни точки за задача могат да се постигнат единствено ако се използва accumulate и/или accumulate-i, вместо рекурсия. Това условие важи и за помощните функции, участващи в решението.

Решения на задачи, които използват рекурсия директно или в помощна функция, ще бъдат оценявани с половината иначе заслужени точки.

(define (accumulate op nv a b term next)
  (if (> a b) nv
      (op (term a)
          (accumulate op nv (next a) b term next))))
(define (accumulate-i op nv a b term next)
    (if (> a b) nv
        (accumulate-i op (op nv (term a)) (next a) b term next)))
Задача 1
Да се напише функция (argmin f a b), която връща такова число от целочисления интервал [a;b], за което едноместната функция f връща най-ниска стойност. Забележете, че върнатите от f стойности иначе не ни интересуват. При повече от един минимуми е без значение кой от тях ще бъде върнат.

(define (mod7 x) (modulo x 7))
(argmin mod7 45 50) -> 49
Задача 2
Да се напише функция (best-pair a b), която връща такава двойка числа (x . y) от целочисления интервал [a;b], за която x+y е с максимален брой делители, където x<y и a<b.

(best-pair 10 20) -> (16 . 20) ; или (17 . 19), но не и (18 . 18) :)
Задача 3
Припомнете си примерa от лекции за интегриране на едноместна числена функция чрез суми на Риман с дадена "стъпка" dx. Да се напише функция (integrate2 f a b c d dx dy), която по аналогичен начин смята приближение на двойния определен интеграл на двуместната функция f(x,y), по x в интервала [a;b] и по y в интервала [c;d]:

integral_c^d integral_a^b f(x, y) dx dy

Упътване: двоен интеграл се изчислява като първо се интегрира по външната променлива (в случая y), а после по другата. Използвайки Риманови суми, това значи за всяко y в интервала (със стъпка dy) да се изчислява интеграла на f(x,y) по x като едноместна функция с фиксирана стойност на y (и стъпка dx), и да се сумират получените едномерни интеграли.

(define pi 3.14159265359)
(define (f x y) (+ x (sin y) 1))
(let ((res (integrate2 f 0 2 (- pi) pi 0.01 0.01)))
  (/ res pi)) -> приблизително 8; забележете по-високите стойности за dx и dy
Визуализация на горния интеграл можете да намерите тук:


Задача 4
На шахматна дъска с размер n на n са поставени известен брой фигури. Ще приемем, че и редовете, и стълбовете се индексират с цели числа, започващи от 0. Да се напише функция n-rooks, която по дадено n и описание на поставните фигури (вж. по-долу) проверява дали е вярно, че във всеки ред има по точно една фигура и във всеки стълб има по точно една фигура. Можете да изберете един от двата дадени по-долу варианта за описание на поставените фигури:

Вариант 1 Функция, която проверява има ли фигура на дадено поле по неговите координати (и големината на дъската):

(define (board1 x y n)
  (= (remainder (+ x 2) n) y))
(define (board2 x y n)
  (= (min (+ x 2) (- n 1)) y))
(n-rooks board1 5) -> #t
(n-rooks board2 5) -> #f
Вариант 2 Списък от наредени двойки с координатите на заетите полета:

(define board1 (list (cons 0 2) (cons 1 3) (cons 2 4) (cons 3 0) (cons 4 1)))
(define board2 (list (cons 0 2) (cons 1 3) (cons 2 4) (cons 3 2)))
(n-rooks board1 5) -> #t
(n-rooks board2 5) -> #f
Моля, предайте само един файл с разширение .scm, .rkt или .zip с Вашите решения на задачите.

Използвайте следния шаблон за името на файла: specX_groupY_fnZ, където X ∈ {CS, I, SE, AM} е Вашата специалност, Y ∈ {1, 2, 3, 4, E} е групата, с която посещавате упражнения, а Z е факултетния Ви номер (с колкото и букви/цифри е).

Например, ако сте с факултетен номер 0MI1234567, от специалност КН, група 1: specCS_group1_fn0MI1234567.scm